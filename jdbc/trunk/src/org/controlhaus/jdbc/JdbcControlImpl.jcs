/*
 * Copyright 2004 BEA Systems, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.controlhaus.jdbc;

import org.apache.beehive.controls.api.ControlException;
import org.apache.beehive.controls.api.bean.ControlImplementation;
import org.apache.beehive.controls.api.bean.Extensible;
import org.apache.beehive.controls.api.context.ControlBeanContext;
import org.apache.beehive.controls.api.context.ResourceContext;
import org.apache.beehive.controls.api.context.ResourceContext.ResourceEvents;
import org.apache.beehive.controls.api.events.EventHandler;
import org.apache.log4j.Logger;
import org.controlhaus.jdbc.parser.SqlParser;
import org.controlhaus.jdbc.parser.SqlStatement;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import javax.sql.RowSet;
import java.lang.reflect.Method;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.DatabaseMetaData;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Properties;
import java.util.Vector;

/**
 * The implementation class for the database controller.
 */
@ControlImplementation
public class JdbcControlImpl implements JdbcControl, Extensible {

    //
    // contexts provided by the beehive controls runtime
    //
    @org.apache.beehive.controls.api.context.Context protected ControlBeanContext _context;
    @org.apache.beehive.controls.api.context.Context protected ResourceContext _resourceContext;

    protected transient Connection _connection;
    protected transient ConnectionDataSource _connectionDataSource;
    protected transient DataSource _dataSource;
    protected transient ConnectionDriver _connectionDriver;
    protected HashMap<Class, ResultSetMapper> _resultMappers;
    protected Class _xmlObjectClass;

    private static final String EMPTY_STRING = "";
    private static final Logger logger = Logger.getLogger(JdbcControlImpl.class);
    private static final ResultSetMapper DEFAULT_MAPPER = new DefaultObjectResultSetMapper();
    private static final SqlParser _sqlParser = new SqlParser();

    private transient Calendar _cal;

    private Vector _resources = new Vector();


    /**
     * Constructor
     */
    public JdbcControlImpl() {

        _resultMappers = new HashMap<Class, ResultSetMapper>();
        _resultMappers.put(ResultSet.class, new DefaultResultSetMapper());
        _resultMappers.put(Iterator.class, new DefaultIteratorResultSetMapper());

        try {
            _xmlObjectClass = Class.forName("org.apache.xmlbeans.XmlObject");
            _resultMappers.put(_xmlObjectClass, new DefaultXmlObjectResultSetMapper());
        } catch (ClassNotFoundException e) {
            // noop: OK if not found, just can't support mapping to an XmlObject
        }
    }


    /**
     * Invoked by the controls runtime when a new instance of this class is aquired by the runtime
     */
    @EventHandler(field = "_resourceContext", eventSet = ResourceEvents.class, eventName = "onAcquire")
    public void onAquire() {
        logger.info("onAcquire() invoked.");
        try {
            getConnection();
        } catch (SQLException se) {
            logger.error("SQL Exception while attempting to connect to database.", se);
        }
    }

    /**
     * Invoked by the controls runtime when an instance of this class is released by the runtime
     */
    @EventHandler(field = "_resourceContext", eventSet = ResourceContext.ResourceEvents.class, eventName = "onRelease")
            public void onRelease() {
        logger.info("onRelease() invoked.");

        for (int i = 0; i < _resources.size(); i++) {

            Object o = _resources.get(i);
            if (o instanceof PreparedStatement) {
                try {
                    ((PreparedStatement) o).close();
                } catch (SQLException sqe) {
                }
            } else {
                throw new ControlException("Unexpected resource type: " + o.getClass().toString());
            }
        }
        _resources.clear();

        if (_connection != null) {
            try {
                _connection.close();
            } catch (SQLException e) {
                logger.error("SQL Exception while attempting to close database connection.", e);
            }
        }

        _connection = null;
        _connectionDataSource = null;
        _connectionDriver = null;
    }

    /**
     * Returns a database connection to the server associated with the control.
     * The connection type is specified by a ConnectionDataSource or ConnectionDriver annotation on the control class
     * which extends this control.
     * <p/>
     * It is typically not necessary to call this method when using the control.
     */
    public Connection getConnection() throws SQLException, ControlException {

        if (_connection != null) {
            return _connection;
        }

        //JdbcControl.ConnectionDataSource _connSourceProp = _context.getControlPropertySet(ConnectionDataSource.class);
        _connectionDataSource = _context.getControlPropertySet(ConnectionDataSource.class);
        if (_connectionDataSource != null && _connectionDataSource.jndiName() != null) {
            return getConnectionFromDataSource(_connectionDataSource.jndiName(), _connectionDataSource.jndiContextFactory());
        }

        _connectionDriver = _context.getControlPropertySet(ConnectionDriver.class);
        if (_connectionDriver != null && _connectionDriver.databaseDriverClass() != null) {
            return getConnectionFromDriverManager(_connectionDriver.databaseDriverClass(), _connectionDriver.databaseURL(),
                                                  _connectionDriver.userName(), _connectionDriver.password(), _connectionDriver.properties());
        }

        throw new ControlException("no @\'" + ConnectionDataSource.class.getName()
                                   + "\' or \'" + ConnectionDriver.class.getName() + "\' property found.");
    }


    /**
     * Called by the Controls runtime to handle calls to methods of an extensible control.
     *
     * @param method The extended operation that was called.
     * @param args   Parameters of the operation.
     * @return The value that should be returned by the operation.
     * @throws Throwable any exception declared on the extended operation may be
     *                   thrown.  If a checked exception is thrown from the implementation that is not declared
     *                   on the original interface, it will be wrapped in a ControlException.
     */
    public Object invoke(Method method, Object[] args) throws Throwable {

        logger.info("Enter: invoke()");
        assert _connection.isClosed() == false : "invoke(): JDBC Connection has been closed!!!!";
        return execPreparedStatement(method, args);
    }

    /**
     * Sets the calendar used when working with time/date types
     */
    public void setDataSourceCalendar(Calendar cal) {
        _cal = (Calendar) cal.clone();
    }

    /**
     * Returns the calendar used when working with time/date types.
     *
     * @return
     */
    public Calendar getDataSourceCalendar() {
        return _cal;
    }


// /////////////////////////////////////////// Protected Methods ////////////////////////////////////////////


    /**
     * Create and exec the query
     * @param method
     * @param args
     * @return
     * @throws Throwable
     */
    protected Object execPreparedStatement(Method method, Object[] args)
            throws Throwable {

        final SQL methodSQL = (SQL) _context.getMethodPropertySet(method, SQL.class);
        if (methodSQL == null) {
            throw new ControlException("Method " + method.getName() + " is missing @SQL annotation");
        }

        final boolean isBatchUpdate = methodSQL.batchUpdate();
        final boolean getGeneratedKeys = methodSQL.getGeneratedKeys();
        final int maxRows = methodSQL.maxRows();
        final int maxArray = methodSQL.arrayMaxLength();
        final String[] genKeyColumnNames = methodSQL.generatedKeyColumnNames();
        final int[] genKeyColumnIndexes = methodSQL.generatedKeyColumnIndexes();
        final String sqlStatement = methodSQL.statement();
        final Class resultSetMapperClass = methodSQL.resultSetMapper();

        //
        // if generated keys requested make sure db impl supports it.
        //
        if (getGeneratedKeys) {
            DatabaseMetaData dmd = _connection.getMetaData();
            if (!dmd.supportsGetGeneratedKeys()) {
                throw new ControlException("The database does not support getGeneratedKeys.");
            }
        }

        PreparedStatement ps = null;
        try {
            Class returnType = method.getReturnType();

            SqlStatement parsedSql = _sqlParser.parse(sqlStatement);
            ps = parsedSql.createPreparedStatement(_context, _connection, _cal, method,  args,
                                                   isBatchUpdate, getGeneratedKeys, 
                                                   genKeyColumnNames, genKeyColumnIndexes);

            //
            // process row limits
            //
            final boolean isArray = returnType.isArray();
            final boolean isRowSet = returnType.equals(RowSet.class);

            int maxSet = maxRows;
            if (isArray && maxArray != -1) {
                maxSet = maxRows == -1 ? maxArray + 1 : Math.min(maxArray + 1, maxRows);
            } else if (isRowSet && maxRows > 0) {
                maxSet = maxRows + 1;
            }

            if (maxSet != -1) {
                ps.setMaxRows(maxSet);
            }

            //
            // special processing for batch updates
            //
            if (isBatchUpdate) {
                return ps.executeBatch();
            }

            //
            // execute
            //
            boolean hasResults = ps.execute();


            //
            // callable statement
            //
            if (parsedSql.isCallableStatement()) {
                SQLParameter[] params = (SQLParameter[]) args[0];
                for (int i = 0; i < params.length; i++) {
                    if (params[i].dir != SQLParameter.IN) {
                        params[i].value = ((CallableStatement) ps).getObject(i + 1);
                    }
                }
                return null;
            }


            //
            // process returned data
            //
            ResultSet rs = null;
            int updateCount = ps.getUpdateCount();

            if (hasResults) {
                rs = ps.getResultSet();
            }

            if (getGeneratedKeys) {
                rs = ps.getGeneratedKeys();
                hasResults = true;
            }

            if (!hasResults && updateCount > -1) {
                boolean moreResults = ps.getMoreResults();
                int tempUpdateCount = ps.getUpdateCount();

                while ((moreResults && rs == null) || tempUpdateCount > -1) {
                    if (moreResults) {
                        rs = ps.getResultSet();
                        hasResults = true;
                        moreResults = false;
                        tempUpdateCount = -1;
                    } else {
                        moreResults = ps.getMoreResults();
                        tempUpdateCount = ps.getUpdateCount();
                    }
                }
            }

            Object returnObject = null;
            if (hasResults) {

                //
                // if a result set mapper was specified in the methods annotation, use it
                // otherwise find the mapper for the return type in the hashmap
                //
                final ResultSetMapper rsm;
                if (!UndefinedResultSetMapper.class.isAssignableFrom(resultSetMapperClass)) {
                    if (ResultSetMapper.class.isAssignableFrom(resultSetMapperClass)) {
                        rsm = (ResultSetMapper)resultSetMapperClass.newInstance();
                    } else {
                        throw new ControlException("Result set mappers must be subclasses of ResultSetMapper.class!");
                    }
                } else {
                    if (_resultMappers.containsKey(returnType)) {
                        rsm = _resultMappers.get(returnType);
                    } else {
                        if (_xmlObjectClass != null && _xmlObjectClass.isAssignableFrom(returnType)) {
                            rsm = _resultMappers.get(_xmlObjectClass);
                        } else {
                            rsm = DEFAULT_MAPPER;
                        }
                    }
                }

                returnObject = rsm.mapToResultType(_context, method, rs, _cal);
                if (rsm.canCloseResultSet() == false) {
                    _resources.add(ps);
                }

                //
                // empty ResultSet
                //
            } else {
                if (returnType.equals(Void.TYPE)) {
                    returnObject = null;
                } else if (returnType.equals(Integer.TYPE)) {
                    returnObject = new Integer(updateCount);
                } else if (!parsedSql.isCallableStatement()) {
                    throw new ControlException("Method " + method.getName() + "is DML but does not return void or int");
                }
            }
            return returnObject;

        } finally {
            // Keep statements open that have in-use result sets
            if (ps != null && !_resources.contains(ps)) {
                ps.close();
            }
        }
    }

// /////////////////////////////////////////// Private Methods ////////////////////////////////////////////

    /**
     * Get a connection from a DataSource.
     *
     * @param jndiName    Specifed in the subclasse's ConnectionDataSource annotation
     * @param jndiFactory Specified in the subclasse's ConnectionDataSource Annotation.
     * @return null if a connection cannot be established
     */
    private Connection getConnectionFromDataSource(String jndiName, Class<? extends IJndiContextFactory> jndiFactory) {

        try {
            IJndiContextFactory jf = (IJndiContextFactory) jndiFactory.newInstance();
            InitialContext jndiContext = jf.getInitialContext();
            _dataSource = (DataSource) jndiContext.lookup(jndiName);
            _connection = _dataSource.getConnection();
        } catch (IllegalAccessException iae) {
            logger.error("Jndi illegal access exception!", iae);
        } catch (InstantiationException ie) {
            logger.error("Jndi instantiation exception!", ie);
        } catch (NamingException ne) {
            logger.error("Jndi nameing exception!", ne);
        } catch (SQLException sqe) {
            logger.error("SQL exception!", sqe);
        }
        return _connection;
    }

    /**
     * Get a JDBC connection from the DriverManager.
     *
     * @param dbDriverClassName Specified in the subclasse's ConnectionDriver annotation.
     * @param dbUrlStr          Specified in the subclasse's ConnectionDriver annotation.
     * @param userName          Specified in the subclasse's ConnectionDriver annotation.
     * @param password          Specified in the subclasse's ConnectionDriver annotation.
     * @return null if a connection cannot be established.
     */
    private Connection getConnectionFromDriverManager(String dbDriverClassName, String dbUrlStr,
                                                      String userName, String password, String propertiesString) {

        try {
            Class.forName(dbDriverClassName);
            if (!EMPTY_STRING.equals(userName)) {
                _connection = DriverManager.getConnection(dbUrlStr, userName, password);
            } else if (!EMPTY_STRING.equals(propertiesString)) {
                Properties props = parseProperties(propertiesString);
                if (props == null) {
                    logger.error("Invalide properties annotation value: " + propertiesString);
                    return null;
                }
                _connection = DriverManager.getConnection(dbUrlStr, props);
            } else {
                _connection = DriverManager.getConnection(dbUrlStr);
            }
        } catch (ClassNotFoundException e) {
            logger.error("Database driver class not found!", e);
        } catch (SQLException e) {
            logger.error("SQL exception while connection to database!", e);
        }
        return _connection;
    }

    /**
     * Parse the propertiesString into a Properties object.  The string must have the format of:
     * propertyName=propertyValue;propertyName=propertyValue;...
     *
     * @param propertiesString
     * @return A Properties instance or null if parse fails
     */
    private Properties parseProperties(String propertiesString) {
        Properties properties = null;
        String[] propPairs = propertiesString.split(";");
        if (propPairs.length > 0) {
            properties = new Properties();
            for (String propPair : propPairs) {
                int eq = propPair.indexOf('=');
                assert eq > -1 : "Invalid properties syntax: " + propertiesString;
                properties.put(propPair.substring(0, eq), propPair.substring(eq + 1, propPair.length()));
            }
        }
        return properties;
    }
}
