/*
 * Copyright 2004 BEA Systems, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.controlhaus.jdbc.parser;

import org.apache.beehive.controls.api.ControlException;
import org.apache.beehive.controls.api.context.ControlBeanContext;
import org.controlhaus.jdbc.JdbcControl;
import org.controlhaus.jdbc.TypeMappingsFactory;

import java.io.Serializable;
import java.lang.reflect.Method;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.Calendar;

/**
 * This class contains the result of the parsing of an SQL statement.
 */
public final class SqlStatement extends SqlFragmentContainer implements Serializable {

    private static final TypeMappingsFactory _tmf = TypeMappingsFactory.getInstance();
    private boolean _callableStatement = false;
    private boolean _cacheableStatement = true;
    private boolean _isBatchUpdate = false;

    /**
     * Constructor
     */
    SqlStatement() {
        super();
    }

    /**
     * Append a fragment to the end of this statement.
     *
     * @param frag
     */
    void addChild(SqlFragment frag) {
        super.addChild(frag);

        if (frag.isDynamicFragment()) {
            _cacheableStatement = false;
        }
    }

    /**
     * Can the PreparedStatement generated by this class be cached?
     *
     * @return
     */
    boolean isCacheable() { return _cacheableStatement; }

    /**
     * Does this SQL generate a callable or prepared statement?
     *
     * @return true if a callable statement will be generated.
     */
    public boolean isCallableStatement() { return _callableStatement; }

    /**
     * Is this a batch update?
     * @return
     */
    public boolean isBatchUpdate() { return _isBatchUpdate; }

    /**
     * Generates the prepared statement for this SQL.
     *
     * @param context    ControlBeanContext instance.
     * @param connection Connection to database.
     * @param calendar   Calendar instance.
     * @param method     Method the SQL is associated with.
     * @param arguments  Method arguments.
     * @return A JDBC PreparedStatement
     * @throws SQLException
     */
    public PreparedStatement createPreparedStatement(ControlBeanContext context, Connection connection,
                                                     Calendar calendar, Method method, Object[] arguments)
            throws SQLException {

        PreparedStatement preparedStatement = null;
        _callableStatement = setCallableStatement(arguments);
        _isBatchUpdate = isBatchUpdate(arguments);

        try {
            final String sql = getPreparedStatementText(context, method, arguments);
            preparedStatement = (_callableStatement) ? connection.prepareCall(sql) : connection.prepareStatement(sql);

            //
            // If the method argument is of type SQLParameter, treat this statement as a CallableStatement,
            //
            if (_callableStatement) {
                for (SqlFragment sf : _children) {
                    if (sf.hasParamValue()) {
                        throw new ControlException("Cannot use parameter substution and SQLParameter array in the same method.");
                    }
                }
                JdbcControl.SQLParameter[] params = (JdbcControl.SQLParameter[]) arguments[0];
                if (params == null) {
                    return preparedStatement;
                }
                for (int i = 0; i < params.length; i++) {
                    JdbcControl.SQLParameter p = params[i];
                    if (p.dir != JdbcControl.SQLParameter.OUT) {
                        Object value = params[i].value;
                        setPreparedStatementParameter(preparedStatement, i + 1, value, params[i].type, calendar);
                    }

                    if (p.dir != JdbcControl.SQLParameter.IN) {
                        ((CallableStatement) preparedStatement).registerOutParameter(i + 1, params[i].type);
                    }
                }

            //
            // special handling for batch updates
            //
            } else if (_isBatchUpdate)  {
                doBatchUpdate(preparedStatement, arguments, calendar);
            //
            // standard case, not a batch or callable
            //
            } else {
                int pIndex = 1;
                for (SqlFragment sf : _children) {
                    if (sf.hasParamValue()) {
                        Object values[] = sf.getParameterValues(context, method, arguments);
                        for (Object value : values) {
                            setPreparedStatementParameter(preparedStatement, pIndex++, value, sf.getParamSqlDataType(), calendar);
                        }
                    }
                }
            }
        } catch (SQLException e) {
            if (preparedStatement != null) preparedStatement.close();
            throw e;
        }
        return preparedStatement;
    }



    // /////////////////////////////////////////////////// PRIVATE METHODS ///////////////////////////////////////////

    /**
     * Sets the specified parameter in the prepared statement.
     *
     * @param ps
     * @param i
     * @param value
     * @param sqlType
     * @param cal
     * @throws SQLException
     */
    private void setPreparedStatementParameter(PreparedStatement ps, int i, Object value, int sqlType, Calendar cal)
            throws SQLException {

        if (sqlType == Types.NULL) {
            sqlType = _tmf.getSqlType(value);
        }

        if (value == null) {
            ps.setNull(i, Types.NULL == sqlType ? Types.VARCHAR : sqlType);
            return;
        }

        switch (sqlType) {

            case Types.VARCHAR:
                if (!(value instanceof String)) value = value.toString();
                break;

            case Types.BOOLEAN:
                if (value instanceof Boolean) {
                    ps.setBoolean(i, ((Boolean) value).booleanValue());
                    return;
                }
                break;

            case Types.TIMESTAMP:
                if (value instanceof java.util.Calendar) {
                    Calendar calValue = (Calendar) value;

// @todo: validate it is correct to comment out call to deprectated method
//                    if (cal == null) {
//                        /* NOTE: drivers are inconsistent in their handling of setTimestamp(i,date,cal)
//                         * so we won't use that, unless the user calls setCalendar().
//                         * I'm going with the theory that it makes sense to store
//                         * the time relative to the Calendar's timezone rather than
//                         * the system timezone otherwise, using a Calendar would be a no-op.
//                         */
//                        value = new java._sql.Timestamp(calValue.get(Calendar.YEAR) - 1900,
//                                                       calValue.get(Calendar.MONTH),
//                                                       calValue.get(Calendar.DATE),
//                                                       calValue.get(Calendar.HOUR_OF_DAY),
//                                                       calValue.get(Calendar.MINUTE),
//                                                       calValue.get(Calendar.SECOND),
//                                                       calValue.get(Calendar.MILLISECOND));
//                    } else {
                    value = new java.sql.Timestamp(calValue.getTimeInMillis());
//                    }
                } else if (java.util.Date.class.equals(value.getClass())) {
                    // some drivers don't like java.util.Date
                    value = new java.sql.Timestamp(((java.util.Date) value).getTime());
                }

                if (value instanceof java.sql.Timestamp) {
                    if (cal == null)
                        ps.setTimestamp(i, (java.sql.Timestamp) value);
                    else
                        ps.setTimestamp(i, (java.sql.Timestamp) value, cal);
                    return;
                }
                break;

            case Types.DATE:
                if (value instanceof java.util.Calendar) {
                    /* NOTE: see note above
                     Calendar cal = (Calendar)value;
                     value = new java._sql.Date(cal.getTimeInMillis());
                     ps.setDate(i, (java._sql.Date)value, cal);
                     return;
                     */
                    Calendar calValue = (Calendar) value;

                    // @todo: validate that commenting out deprected method is correct behavior
//                    if (cal == null) {
//                        value = new java._sql.Date(calValue.get(Calendar.YEAR - 1900),
//                                                  calValue.get(Calendar.MONTH),
//                                                  calValue.get(Calendar.DATE));
//                    } else {
                    value = new java.sql.Date(calValue.getTimeInMillis());
//                    }
                } else if (value.getClass() == java.util.Date.class) {
                    // some drivers don't like java.util.Date
                    value = new java.sql.Date(((java.util.Date) value).getTime());
                }

                if (value instanceof java.sql.Date) {
                    if (cal == null) {
                        ps.setDate(i, (java.sql.Date) value);
                    } else {
                        ps.setDate(i, (java.sql.Date) value, cal);
                    }
                    return;
                }
                break;

            case Types.TIME:
                if (value instanceof java.sql.Time) {
                    if (cal == null) {
                        ps.setTime(i, (java.sql.Time) value);
                    } else {
                        ps.setTime(i, (java.sql.Time) value, cal);
                    }
                    return;
                }
                break;
        }

        if (sqlType == Types.NULL) {
            ps.setObject(i, value);
        } else {
            ps.setObject(i, value, sqlType);
        }
    }

    /**
     * Determine if this SQL will generate a callable or prepared statement.
     *
     * @param args The method's argument list which this SQL annotation was assocatied with.
     * @return
     */
    private boolean setCallableStatement(Object[] args) {

        // CallableStatement vs. PreparedStatement
        if (args != null && args.length == 1 && args[0] != null) {
            Class argClass = args[0].getClass();
            if (argClass.isArray() && JdbcControl.SQLParameter.class.isAssignableFrom(argClass.getComponentType())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Should this update be done as a batch update? Yes if all parameters
     * are arrays and this is not a callable statement
     *
     * @param args
     * @return
     */
    private boolean isBatchUpdate(Object[] args) {

        if (args != null && args.length > 1) {
            for (int i = 0; i < args.length; i++) {
                Class argClass = args[i].getClass();
                if (!argClass.isArray()) {
                    return false;
                }
            }
        } else {
            return false;
        }

        final int arraySize = ((Object[])args[0]).length;
        for (int i = 1; i < args.length; i++) {

           if (((Object[])args[0]).length != arraySize) {
                //@todo: throw control exception in this case?
                return false;
           }
        }
        return true;
    }


    /**
     * Build a prepared statement for a batch update
     * @param ps
     * @param args
     * @param cal
     * @throws SQLException
     */
    private void doBatchUpdate(PreparedStatement ps, Object[] args, Calendar cal) throws SQLException {

        final int updateCount = ((Object[])args[0]).length;
        final int[] sqlTypes = new int[args.length];
        final Object[] objArrays = new Object[args.length];

        // build an array of type values
        for (int i = 0; i < args.length; i++) {
            sqlTypes[i] = _tmf.getSqlType(args[i].getClass().getComponentType());
            objArrays[i] = TypeMappingsFactory.toObjectArray(args[i]);
        }

        for (int i = 0; i < updateCount; i++) {
            for (int j = 0; j < args.length; j++) {
               setPreparedStatementParameter(ps, j+1, ((Object[])objArrays[j])[i], sqlTypes[j], cal);
            }
            ps.addBatch();
        }
    }
}
