package org.controlhaus.ejb;

/******************************************************************************
* WARNING: THIS CLASS IS INCLUDED INSIDE OF SERIALIZED CONVERSATIONAL STATE
* OR ASYNCHRONOUS REQUESTS.   THIS CLASS MUST REMAIN SERIALIZATION COMPATIBLE
* OR EXISTING STATE/REQUESTS MAY BECOME INVALIDATED.   IF YOU AREN'T CLEAR ON
* THE IMPLICATIONS OF THIS STATEMENT, TURN BACK NOW.
******************************************************************************/

import org.apache.beehive.controls.api.ControlException;
import org.apache.beehive.controls.api.bean.ControlImplementation;
import org.apache.beehive.controls.api.bean.Extensible;
import org.apache.beehive.controls.api.context.Context;
import org.apache.beehive.controls.api.context.ControlBeanContext;
import org.apache.beehive.controls.api.context.ControlBeanContext.LifeCycle;
import org.apache.beehive.controls.api.context.ResourceContext;
import org.apache.beehive.controls.api.context.ResourceContext.ResourceEvents;
import org.apache.beehive.controls.api.events.EventHandler;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import java.util.Vector;

import javax.ejb.CreateException;
import javax.ejb.EJBLocalHome;
import javax.ejb.EJBLocalObject;
import javax.ejb.EJBObject;
import javax.ejb.Handle;
import javax.ejb.FinderException;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.rmi.PortableRemoteObject;

import java.net.URLConnection;

/**
 * The Enterprise Java Bean Control implementation class
 */
@ControlImplementation
abstract public class EJBControlImpl implements EJBControl, Extensible
{
    static final long serialVersionUID = 1L;

    static public final int     SESSION_BEAN      = 1;
    static public final int     ENTITY_BEAN       = 2;

    static public final String  JNDI_GLOBAL_PREFIX  = "jndi:";
    static public final String  JNDI_APPSCOPED_PREFIX    = "java:comp/env/";

    @EventHandler(field="context", eventSet=LifeCycle.class, eventName="onCreate")
    public void onCreate()
    {
        // first time initialization

        // assume v2 attributes
        EJBHome ejbHome = (EJBHome)context.getControlPropertySet(EJBHome.class);
        if (ejbHome == null)
        {
            throw new ControlException("No @EJBHome property is defined");
        }
        _jndiName = ejbHome.JNDIName();
        if (_jndiName.length() != 0)
        {
            if (!_jndiName.toLowerCase().startsWith(JNDI_GLOBAL_PREFIX) ||
                !_jndiName.toLowerCase().startsWith(JNDI_APPSCOPED_PREFIX))
            {
                _jndiName = JNDI_GLOBAL_PREFIX + _jndiName;
            }
        }
        else
        {
            String ejbLink = ejbHome.EJBLink();
            if (ejbLink.length() == 0)
            {
                //
                // Should be caught by the compiler
                //
                throw new ControlException(
                          "Either the JNDIHome() or EJBLink() member of @EJBHome must be defined.");
            }

            //
            // Generate a unique local jndi name to associate w/ the link,
            // based upon the local control service uri and control id
            //
            _jndiName = JNDI_APPSCOPED_PREFIX +
                        EJBInfo.getEJBRefName(context.getControlInterface());
        }

        // Obtain the JCX interface and identify the home/remote
        // interfaces.
        EJBInfo beanInfo = new EJBInfo(context.getControlInterface());
        _homeInterface = beanInfo._homeInterface;
        _beanInterface = beanInfo._beanInterface;
        _beanType = beanInfo._beanType.equals("Session") ? SESSION_BEAN : ENTITY_BEAN;
    }

    static protected boolean methodThrows(Method m, Class exceptionClass)
    {
        Class [] exceptions = m.getExceptionTypes();
        for (int j = 0; j < exceptions.length; j++)
            if (exceptionClass.isAssignableFrom(exceptions[j]))
                return true;
        return false;
    }

    protected boolean isHomeMethod(Method m)
    {
         return m.getDeclaringClass().isAssignableFrom(_homeInterface);
    }

    static protected boolean isCreateMethod(Method m)
    {
        return methodThrows(m, CreateException.class);
    }

    static protected boolean isFinderMethod(Method m)
    {
        if (!m.getName().startsWith("find")) // EJB enforced pattern
            return false;
        return methodThrows(m, FinderException.class);
    }

    protected boolean isSelectorMethod(Method m)
    {
        if (isHomeMethod(m) &&
            m.getReturnType().equals(_beanInterface))
            return true;
        return false;
    }

    static protected boolean isRemoveMethod(Method m)
    {
        if (!m.getName().equals("remove") ||
            (m.getParameterTypes().length != 0))
            return false;

        return true;
    }

    protected Object homeNarrow(Object obj)
    {
        if (javax.ejb.EJBHome.class.isAssignableFrom(_homeInterface))
            return PortableRemoteObject.narrow(obj, _homeInterface);
        return obj;
    }

    protected Object beanNarrow(Object obj)
    {
        if (javax.ejb.EJBObject.class.isAssignableFrom(_beanInterface))
            return PortableRemoteObject.narrow(obj, _beanInterface);
        return obj;
    }

    /*
     * This method is implemented by the appropriate bean type-specific
     * control to provide auto create/find semantics for bean instances.
     *
     * IT SHOULD ALWAYS THROW A RUNTIME EXCEPTION WITH A TYPE-SPECIFIC
     * ERROR MESSAGE IF RESOLUTION CANNOT TAKE PLACE.  IT SHOULD _NEVER_
     * HAVE A NON-EXCEPTED RETURN WHERE _beanInstance == null.
     */
    abstract protected Object resolveBeanInstance();

    //
    // Is there is a cached EJB handle associated with this bean, then
    // is it to restore the associate EJB object reference.
    //
    protected Object resolveBeanInstanceFromHandle()
    {
        if (_beanHandle == null)
            return null;

        try
        {
            return _beanHandle.getEJBObject();
        }
        catch (java.rmi.RemoteException re)
        {
            throw new ControlException("Unable to convert EJB handle to object", re);
        }
    }

    //
    // Attempts to save the contents of the current bean reference in persisted
    // control state.  Returns true if state could be saved, false otherwise
    //
    protected boolean saveBeanInstance()
    {
        // Nothing to save == success
        if (_beanInstance == null)
            return true;

        //
        // Save using a bean handle, but handles only exist for remote objects.
        //
        if (_beanInstance instanceof EJBObject)
        {
            try
            {
                _beanHandle = ((EJBObject)_beanInstance).getHandle();
            }
            catch (java.rmi.RemoteException re)
            {
                throw new ControlException("Unable to get bean instance from handle", re);
            }

            return true;
        }
        return false;
    }

    //
    // This is called whenever a bean reference is being dropped, and is the
    // provides an opportunity to reset cached state or release non-persisted
    // resources associated with the instance.
    //
    protected void releaseBeanInstance(boolean alreadyRemoved)
    {
        _beanInstance = null;
        _beanHandle = null;
    }

    @EventHandler(field="resourceContext", eventSet=ResourceEvents.class, eventName="onAcquire")
    public void onAcquire()
    {
        // Compute the home instance cache lookup key.  The Service URI must
        // be taken into account because different services use different
        // class loaders.  The JNDI home must be taken into account because
        // it is possible to be a remote client of the same bean type on two
        // different providers.
        //
        if (_homeInstance == null)
        {
            // Convert basic local name to JNDI URL syntax
            if (!_jndiName.toLowerCase().startsWith(JNDI_GLOBAL_PREFIX))
                _jndiName = JNDI_GLOBAL_PREFIX + _jndiName;

            URLConnection jndiConn = null;
            try
            {
                URL url = new URL(_jndiName);
                jndiConn = url.openConnection();
                _homeInstance = jndiConn.getContent();
            }
            catch (MalformedURLException mue)
            {
                throw new ControlException(_jndiName +
                            " is not a valid JNDI URL", mue);
            }
            catch (IOException ioe)
            {
                throw new ControlException("Error during JNDI lookup from "+
                                           _jndiName, ioe);
            }
            finally
            {
                try { if (jndiConn != null) { /* jndiConn.disconnect();*/ } }
                catch (RuntimeException re) { throw re; }
                catch (Exception e)
                {
                }
            }

            if (!_homeInterface.isAssignableFrom(_homeInstance.getClass()))
            {
                throw new ControlException("JNDI lookup of " + _jndiName +
                            " failed to return an instance of " +
                            _homeInterface);
            }
        }
    }

    @EventHandler(field="resourceContext", eventSet=ResourceEvents.class, eventName="onRelease")
    public void onRelease()
    {
        //
        // If conversational, attempt to save the bean reference,
        // else always release it if stateless or not persistable.
        //
        //if (context.getService().getConversationID() == null ||
        if (!saveBeanInstance())
        {
            releaseBeanInstance(false);
        }
    }

    //@EventHandler(field="context", eventSet=LifeCycle.class, eventName="onReset")
    public void onReset()
    {
        _lastException = null;
        // other work in onRelease(), delivered prior to reset event
    }

    /**
     * Extensible.invoke
     * Handles all extended interface methods (i.e. EJB home and remote
     * interface invocation)
     */
    public Object invoke(Method m, Object[] args) throws Throwable
    {
        Object retval = null;

        if (isHomeMethod(m))
        {
            try
            {
                retval = m.invoke(_homeInstance, args);
            }
            catch (Exception e)
            {
                Throwable t = e;
                if (e instanceof InvocationTargetException)
                    t = ((InvocationTargetException)e).getTargetException();

                _lastException = t;

                throw t;
            }

            // If the method was successful and returns an instance of
            // the bean interface class, then reset the target instance.
            if (isSelectorMethod(m))
            {
                releaseBeanInstance(false);
                retval = beanNarrow(retval);
                _beanInstance = retval;
            }


            return retval;
        }
        else // is remote / bean interface
        {
            if (_beanInstance == null)
                _beanInstance = resolveBeanInstance();

            // By convention, the below cond should never be true.  The bean
            // type-specific resolve should throw an appropriate exception
            // that is more specific.  This is a safety net.
            if (_beanInstance == null)
            {
                throw new ControlException("Unable to resolve bean instance");
            }

            try
            {
                return m.invoke(_beanInstance, args);
            }
            catch (Exception e)
            {
                Throwable t = e;
                if (e instanceof InvocationTargetException)
                    t = ((InvocationTargetException)e).getTargetException();
                _lastException = t;

                throw t;
            }
            finally
            {
                // Handle remove method properly
                if (isRemoveMethod(m))
                    releaseBeanInstance(true);
            }
        }
    }

    /**
     * EJBControl.getEJBHomeInstance()
     */
    public Object getEJBHomeInstance()
    {
        return _homeInstance;
    }

    /**
     * EJBControl.getEJBBeanInstance()
     */
    public boolean hasEJBBeanInstance()
    {
        return _beanInstance != null;
    }

    /**
     * EJBControl.getEJBBeanInstance()
     */
    public Object getEJBBeanInstance()
    {
        return _beanInstance;
    }

    /**
     * EJBControl.getEJBException()
     */
    public Throwable getEJBException()
    {
        return _lastException;
    }

    @Context ControlBeanContext context;
    @Context ResourceContext resourceContext;

    protected Class  _controlInterface;
    protected Class  _homeInterface;
    protected Class  _beanInterface;
    protected int    _beanType;
    protected String _jndiName;
    protected Handle _beanHandle;
    transient protected Throwable _lastException; // don't persist
    transient protected Object _beanInstance;     // don't persist
    transient protected Object _homeInstance;     // don't persist
}
